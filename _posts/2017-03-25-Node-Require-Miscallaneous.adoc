= Node Require Miscallaneous ...

So times ago (I don't really remember when), working on a Node.Js project, I realised something about `require`.

== The situation ...

Imagine we have some datas in a Json file we want to access in different modules.

[source, json]
.datas.json
----
{
  "version":"0.1",
  "name":"MyApplication"
}
----

This `datas.json` is quite short, but for explaining the situation it is more than enough !

Now the code : 

[source, js]
.index.js
----
var module1 = require('./module1.js'),
    module2 = require('./module2.js');

module1.log();
module2.log();
----



[source, js]
.module1.js
----
var myDatas = require('./datas.json');

module.exports = {
  log:function(){
    console.log(myDatas);
  }
}
----


[source, js]
.module2.js
----
var myDatas = require('./datas.json');

module.exports = {
  log:function(){
    console.log(myDatas);
  }
}
----

As you can see, `module1` and `module2` are exactly same.

So if we execute the code, we will have the following output : 

[source, zsh]
.output 1
----
⇒  node index.js
{ version: 'O.1', name: 'MyApplication' }
{ version: 'O.1', name: 'MyApplication' }
----

Ok, now imagine `module1` will modify some value before logging : 

[source, js]
.module1.js (version 2)
----
var myDatas = require('./datas.json');

module.exports = {
  log:function(){
    lowerCaseName() <1>
    console.log(myDatas);
  }
}

function lowerCaseName(){
  myDatas.name = myDatas.name.toLowerCase();
}
----
<1> We just add this simple function that will lowerCase the name.

In my idea, this should not affect the `module2` as they should be independant, so when I execute the code, here is the output : 

[source, zsh]
.output 2
----
⇒  node index.js
{ version: 'O.1', name: 'myapplication' }
{ version: 'O.1', name: 'myapplication' }<1>
----
<1> Damned ! 

== Why 

Actually the reason is quite simple, when you require the file `datas.json`, require will create the object and store it in the `require.cache` object, then next time you use `require('./datas.json')` to retreive the datas, require will return you the value in that `require.cache` object.

So it mean that it gives you the reference to the value, so if you change one property of that value, all other modules are affected as you are actually doing the change on the reference in the cache.

.This is quite well documented in the Node.js documentation : 
[quote, Node.Js Documentation, https://nodejs.org/api/modules.html#modules_caching]
____
Modules are cached after the first time they are loaded. This means (among other things) that every call to require('foo') will get exactly the same object returned, if it would resolve to the same file.
____


[IMPORTANT]
----
Remember that Node.Js is single thread, it mean for example that the require cache is shared accross all requests
----


== How to have the desired behaviour

So now, how can we do to be able to edit values without changing affecting other modules.

=== The _Const_ way ... fail

First I wanted to use the new ES6 `const` instead of `var` in the line 

[source, js]
----
// replace 
var myDatas = require('./datas.json');
// with 
const myDatas = require('./datas.json');
----

But actually, `const` do not prevent the variable to be modified, but prevent reafectation, so [red big]#this can not work#

[source, zsh]
.output 3
----
⇒  node index.js
{ version: 'O.1', name: 'myapplication' }
{ version: 'O.1', name: 'myapplication' }<1>
----
<1> Damned ! 


=== The _delete_ way ... success

With this solution, you will `delete` the reference in the `require.cache` object before require the `datas.json` file like this : 

[source, js]
----
delete require.cache[require.resolve('./datas.json')];
var myDatas = require('./datas.json');
// Code continue ...
----

As you may not know how your modules are inserted, you need to add the line on every files that need to use the `datas.json` file.

In my opinion, this is not very convenient, but it works : 

[source, zsh]
.output 4
----
⇒  node index.js
{ version: 'O.1', name: 'myapplication' }
{ version: 'O.1', name: 'MyApplication' } <1>
----
<1> Great !

I Think that this solution is the *_"Quick And Dirty"_* solution.

=== The _Proxy_ Way ...

With this solution I imagine to create a `Proxy` around the json datas, and override the `set` method, in order to forbid the manipulation of the value.

This approach can be usefull to throw excpetion if someone try to set the property value.

Here is the code : 

[source, js]
.datasProxy.js
----
var datas = require('./datas.json'); <1>

module.exports = new Proxy(datas, {
  set:function(){ 
    return; <2>
  }
});
----
<1> This should be the only location in the app where you require the json file.
<2> Here, we just do nothing, but we could throw exception here to reject any modification of any properties.

We also need to change the reference in `module1` and `module2` :
[source, js]
----
// Replace
var myDatas = require('./datas.json');
// with
var myDatas = require('./datasProxy');
----


Can you see a big problem ? 

YES, the code in `module1` should be updated because now we can not set the property (even locally)

Let's first execute the code without any modification :

[source, zsh]
.output 5
----
⇒  node index.js
{ version: 'O.1', name: 'MyApplication' }
{ version: 'O.1', name: 'MyApplication' }
----

So there is a problem, the first line should display the text MyApplciation in lowercase.
So let's edit the code in `module1` to have the desired behaviour.

Here is a working code : 

[source, js]
.module1.js
----
var myDatas = Object.assign({}, require('./datasProxy')); <1>

module.exports = {
  log:function(){
    lowerCaseName()
    console.log(myDatas);
  }
}

function lowerCaseName(){
  myDatas.name = myDatas.name.toLowerCase();
}
----
<1> We use `Object.assign()` to create a _"copy"_ of the object in the `module1`

If we look at the output : 

[source, zsh]
.output 6
----
⇒  node index.js
{ version: 'O.1', name: 'myapplication' }
{ version: 'O.1', name: 'MyApplication' }
----

So it works ! 

But, as the MDN web site says:

[quote, Mozilla Developper Network, http://devdocs.io/javascript/global_objects/object/assign]
____
"The `Object.assign()` method only copies enumerable and own properties from a source object to a target object."
____
Maybe you should use a "clone" function that allow to clone objects deeply (check this with lodash https://lodash.com/docs/4.17.4#clone[`_.clone()`] for example)

I think this solution is not too bad, but the thing is that you delegate to the module the need to create a copy, maybe this suits your needs, or maybe we can do it in the proxy itself.

I think both solution can be justified, you just need to make a choice.


=== The _Clone_ Way  ...

This solution is the solution I considered previously.

So with this solution, the _"Proxy"_ (or you can call it, the _"wrapper"_) will create the copy and returns it to the modules : 

So edit the Proxy code, and the modules : 

[source, js]
.datasProxy.js
----
var datas = require('./datas.json');

module.exports = function(){ <1>
  return clone(datas);
}

function clone(datas){
  return JSON.parse(JSON.stringify(datas)); <2>
}
----
<1> We export a function that need to be called in module to return a copy of the datas
<2> Here we use a hack to clone _"deeply"_ an object.

Then edit the modules to call the exported function 
 
[source, js]
.module1.js
----
var myDatas = require('./datasProxy')(); <1>

module.exports = {
  log:function(){
    lowerCaseName()
    console.log(myDatas);
  }
}

function lowerCaseName(){
  myDatas.name = myDatas.name.toLowerCase();
}
----
<1> Call the function to get the copy.

[source, js]
.module2.js
----
var myDatas = require('./datasProxy')(); <1>

module.exports = {
  log:function(){
    console.log(myDatas);
  }
}
----
<1> Call the function to get the copy.

Then execute the code : 

[source, zsh]
.output 7
----
⇒  node index.js
{ version: 'O.1', name: 'myapplication' }
{ version: 'O.1', name: 'MyApplication' }
----

Great it works ! 

This is one of my prefered solution.


=== The _ServiceLocator_ Way ... 

With this solution, we will use an object (a kind of registry) that will expose (at least) two methods `get` and `set` and will be inserted in every module to retreive the datas.

This is a way of https://en.wikipedia.org/wiki/Inversion_of_control[_"Inversion Of Control"_] 

As code speak louders, let's write this object : 



=== The _import_ Way (aka. the _ES6_ way)

First I need to say that I first did not considered this solution, this solution was given to me by Jéremy  Morin  (a co-worker).

As Node.JS (version 7.4.0 on my laptop) is not compatible with the ES6 syntax, we will need to _"babelize"_ (transpile with babel) the code, and for that we need to refactor our code, and initilaze a npm project.

1. First create a `src` doirectory and copy all files inside that directory
2. In a terminal window run the `npm init` command and answer all question
3. Then install the `babel-cli` dependency
4. Create a _"build"_ script
4. Edit the Code to convert it to ES6
5. Build
6. Test

==> It does not fix the _cacche_ 


=== The _decache_ way


== Let's talk about unit testing


== Conclusion
